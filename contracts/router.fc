;; ------------------------------------------------------------------------------------------------------------
;; Router contract to distribute funds to protocols for storing lp tokens and withdrawing funds from protocols
;; ------------------------------------------------------------------------------------------------------------

#include "imports/stdlib.fc";
#include "imports/op-codes.fc";
#include "imports/jetton-wallet-utils.fc";
#include "imports/utils.fc";
#include "imports/jetton-wallet-governed-utils.fc";

global slice main_sc_address;
global slice tradoor_master_address;
global slice evaa_master_address;
global slice storm_vault_address;
global slice usdt_jetton_master_address;
global slice usdt_tlp_master_address;
global slice usdt_slp_master_address;
global cell jetton_wallet_code;
global cell jetton_wallet_governed_code;
global int usdt_tlp_amount;
global int usdt_slp_amount;
global int total_deposit_amount;
global int recv_count;

(slice, slice, slice) load_addresses(cell c) inline_ref {
    slice s = c.begin_parse();
    return (
        s~load_msg_addr(),
        s~load_msg_addr(),
        s~load_msg_addr()
    );
}

() load_data() impure inline_ref {
    slice ds = get_data().begin_parse();
    slice main_sc_address = ds~load_msg_addr();
    (
        slice tradoor_master_adderss,
        slice evaa_master_address,
        slice storm_vault_address
    ) = load_addresses(ds~load_ref());
    (
        slice usdt_jetton_master_address,
        slice usdt_tlp_master_address,
        slice usdt_slp_master_address
    ) = load_addresses(ds~load_ref());
    cell jetton_wallet_code = ds~load_ref();
    cell jetton_wallet_governed_code = ds~load_ref();
    int usdt_tlp_amount = ds~load_coins();
    int usdt_slp_amount = ds~load_coins();
    int total_deposit_amount = ds~load_coins();
    int recv_count = ds~load_uint(2);
    ds.end_parse();
}

() save_data() impure inline_ref {
    set_data(
        begin_cell()
        .store_slice(main_sc_address)
        .store_ref(
            begin_cell()
            .store_slice(tradoor_master_address)
            .store_slice(evaa_master_address)
            .store_slice(storm_vault_address)
            .end_cell()
        )
        .store_ref(
            begin_cell()
            .store_slice(usdt_jetton_master_address)
            .store_slice(usdt_tlp_master_address)
            .store_slice(usdt_slp_master_address)
            .end_cell()
        ).store_ref(jetton_wallet_code)
        .store_ref(jetton_wallet_governed_code)
        .store_coins(usdt_tlp_amount)
        .store_coins(usdt_slp_amount)
        .store_coins(total_deposit_amount)
        .store_uint(recv_count, 2)
        .end_cell()
    );
}

() send_mint_user_sc(int query_id, int usdt_tlp_amount, int usdt_slp_amount, int total_deposit_amount) impure inline {
    cell msg_body = begin_cell()
                    .store_uint(op::mint_user_internal, 32)
                    .store_uint(query_id, 64)
                    .store_coins(usdt_tlp_amount)
                    .store_coins(usdt_slp_amount)
                    .store_coins(total_deposit_amount)
                    .end_cell();
    cell msg = begin_cell()
                .store_uint(0x18, 6) 
                .store_slice(main_sc_address)
                .store_coins(30000000) ;; 0.03 tons
                .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1) 
                .store_ref(msg_body)
                .end_cell();
    send_raw_message(msg, SEND_MODE_REGULAR);
}

() update_status(
    slice counter_address,
    slice owner_address,
    int query_id,
    int lp_amount
) impure inline_ref {
    throw_unless(err::unknown_address, equal_slices(counter_address, owner_address));
    load_data();
    if (recv_count > 0) {
        if (equal_slices(counter_address, usdt_tlp_master_address)) {
            usdt_tlp_amount = lp_amount;
        } elseif(equal_slices(counter_address, usdt_slp_master_address)) {
            usdt_slp_amount = lp_amount;
        }
        recv_count -= 1;
        save_data();
    } else {
        send_mint_user_sc(query_id, usdt_tlp_amount, usdt_slp_amount, total_deposit_amount);
        usdt_slp_amount = 0;
        usdt_tlp_amount = 0;
        total_deposit_amount = 0;
    }                   
    return();
}

int is_busy() impure inline_ref {
    load_data();
    return recv_count > 0;
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) {
        ;; ignore bounced messages
        return ();
    }
    if (in_msg_body.slice_bits() < 32) {
        ;; ignore simple transfers
        return ();
    }
    slice sender_address = cs~load_msg_addr();
    (int op, int query_id) = (in_msg_body~load_uint(32), in_msg_body~load_uint(64));

    load_data();
    if (op == op::transfer_notification) {
        throw_unless(err:busy, is_busy());
        
        slice usdt_jetton_wallet_address = get_jetton_wallet_governed_address(my_address(), usdt_jetton_master_address, jetton_wallet_governed_code);

        slice usdt_tlp_jetton_wallet_address = get_jetton_wallet_address(my_address(), usdt_tlp_master_address, jetton_wallet_code);

        slice usdt_slp_jetton_wallet_address = get_jetton_wallet_address(my_address(), usdt_slp_master_address, jetton_wallet_code);

        int jetton_amount = in_msg_body~load_coins();
        slice owner_address = in_msg_body~load_msg_addr();
        in_msg_body~load_msg_addr();
        in_msg_body~load_uint(1);
        in_msg_body~load_coins();
        in_msg_body~load_uint(1);
        slice fwd_payload = in_msg_body~load_ref().begin_parse();

        if (equal_slices(sender_address, usdt_jetton_wallet_address)) {
            if (equal_slices(main_sc_address, owner_address)) {
                ;; set total deposit amount is user usdt amount
                total_deposit_amount = jetton_amount;

                ;; counter update of succeed protocols transfers
                recv_count = 3;

                slice response_user_address = fwd_payload~load_msg_addr();

                int tradoor_deposit_amount = jetton_amount * 40 / 100;
                int storm_deposit_amount = tradoor_deposit_amount;
                int evaa_deposit_amount = jetton_amount * 20 / 100;

                ;; buy tlp
                send_jettons(
                    tradoor_deposit_amount,
                    tradoor_master_address,
                    query_id,
                    usdt_jetton_wallet_address,
                    begin_cell()
                        .store_uint(op::tradoor_create_increase_lp_pos_order, 8)
                        .store_coins(tradoor_deposit_amount)
                        .store_coins(50000000) ;; 0.05 ton
                        .end_cell(),
                    150000000, ;; 0.15 ton
                    100000000, ;; ;; 0.1 ton
                    response_user_address
                );

                ;; strom provide
                send_jettons(
                    storm_deposit_amount,
                    storm_vault_address,
                    query_id,
                    usdt_jetton_wallet_address,
                    begin_cell().store_uint(op::storm_provide, 32).end_cell(),
                    350000000, ;; 0.35 ton
                    305000000, ;; ;; 0.305 ton
                    response_user_address
                );

                ;; evaa supply
                send_jettons(
                    evaa_deposit_amount,
                    evaa_master_address,
                    query_id,
                    usdt_jetton_wallet_address,
                    begin_cell().end_cell(),
                    400000000, ;; 0.4 ton
                    300000000, ;; ;; 0.3 ton
                    response_user_address
                );
            } elseif (equal_slices(tradoor_master_address | evaa_master_address | storm_vault_address, owner_address)) {
                ;; todo: logic of accepting usdt from protocols.
            }
        } elseif (equal_slices(sender_address, usdt_tlp_jetton_wallet_address)) {
            throw_unless(err::unknown_address, equal_slices(usdt_tlp_master_address, owner_address));
            update_status(usdt_tlp_jetton_wallet_address, owner_address, query_id, jetton_amount);
            return();
        } elseif (equal_slices(sender_address, usdt_slp_jetton_wallet_address)) {
            throw_unless(err::unknown_address, equal_slices(usdt_slp_master_address, owner_address));
            update_status(usdt_slp_jetton_wallet_address, owner_address, query_id, jetton_amount);
            return();
        }    
        throw(err::unknown_jetton);
        return ();
    }
    if (op == op::text_comment) {
        update_status(evaa_master_address, sender_address, query_id, 0);
        return();
    }
    if (op == op::withdraw) {
        throw_unless(err::not_admin, equal_slices(sender_address, main_sc_address));

        int user_usdt_tlp_amount = in_msg_body~load_coins();
        int user_usdt_slp_amount = in_msg_body~load_coins();
        int user_total_deposit_amount = in_msg_body~load_coins();
        in_msg_body.end_parse();
        ;; todo: send request to withdraw from protocols
    }
    if (op = op::upgrade_contract) {
        throw_unless(err::not_admin, equal_slices(sender_address, main_sc_address));
        (cell new_data, cell new_code) = (in_msg_body~load_ref(), in_msg_body~load_ref());
        in_msg_body.end_parse();
        set_data(new_data);
        set_code(new_code);
        return ();
    }
    throw(err::unknown_op_code);
}

int check_is_busy() method_id {
    return is_busy();
}
