;; ----------------------------------------------------------------------------------------------------------------------------
;; The main entrypoint sc who send usdt to protocols, control root price, mint user sc's, mint beetroot for users & send yields
;; ----------------------------------------------------------------------------------------------------------------------------

#include "imports/stdlib.fc";
#include "imports/op-codes.fc";
#include "imports/jetton-wallet-utils.fc";
#include "imports/utils.fc";
#include "imports/jetton-wallet-governed-utils.fc";

global slice usdt_jetton_master_address;
global slice root_master_address;
global cell user_sc_code;
global slice admin_address;
global cell jetton_wallet_governed_code;
global cell jetton_wallet_code;
global int root_price;
global slice tradoor_master_address;
global slice evaa_master_address;
global slice storm_vault_address;
global slice usdt_slp_jetton_wallet;
global slice usdt_tlp_jetton_wallet;

() load_data() impure inline_ref {
    slice ds = get_data().begin_parse();

    usdt_jetton_master_address = ds~load_msg_addr();
    root_master_address = ds~load_msg_addr();
    user_sc_code = ds~load_ref();
    admin_address = ds~load_msg_addr();
    jetton_wallet_governed_code = ds~load_ref();
    jetton_wallet_code = ds~load_ref();

    slice protocol_addresses_s = ds~load_ref().begin_parse();
    evaa_master_address = protocol_addresses_s~load_msg_addr();
    tradoor_master_address = protocol_addresses_s~load_msg_addr();
    storm_vault_address = protocol_addresses_s~load_msg_addr();

    slice lp_tokens_wallet_addresses = protocol_addresses_s~load_ref().begin_parse();
    usdt_slp_jetton_wallet = lp_tokens_wallet_addresses~load_msg_addr();
    usdt_tlp_jetton_wallet = lp_tokens_wallet_addresses~load_msg_addr();

    root_price = ds~load_uint(64);

    ds.end_parse();
}

() save_data() impure inline_ref {
    set_data(
        begin_cell()
        .store_slice(usdt_jetton_master_address)
        .store_slice(root_master_address)
        .store_ref(user_sc_code)
        .store_slice(admin_address)
        .store_ref(jetton_wallet_governed_code)
        .store_ref(jetton_wallet_code)
        .store_ref(
            begin_cell()
            .store_slice(evaa_master_address)
            .store_slice(tradoor_master_address)
            .store_slice(storm_vault_address)
            .store_ref(
                begin_cell()
                .store_slice(usdt_slp_jetton_wallet)
                .store_slice(usdt_tlp_jetton_wallet)
                .end_cell()
            )
            .end_cell()
        ).store_uint(root_price, 64)
        .end_cell()
    );
}

() mint_jettons(int query_id, int balance, slice owner_address, int fwd_ton_amount, int msg_value) impure inline {
    cell internal_transfer_body = begin_cell()
        .store_uint(op::internal_transfer, 32)
        .store_uint(query_id, 64)
        .store_coins(balance)
        .store_slice(my_address())
        .store_slice(owner_address)
        .store_coins(fwd_ton_amount)
        .store_uint(0, 1)
        .end_cell();
    slice jetton_mint_body = begin_cell()
        .store_uint(op::mint_jetton, 32)
        .store_uint(query_id, 64)
        .store_slice(owner_address)
        .store_coins(20000000) ;; 0.02 tons
        .store_ref(internal_transfer_body)
        .end_cell()
        .begin_parse();
    cell jetton_mint_msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(root_master_address)
        .store_coins(msg_value)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_slice(jetton_mint_body)
        .end_cell();
    send_raw_message(jetton_mint_msg, SEND_MODE_REGULAR);
}

() mint_user_sc(
    int query_id,
    int total_deposit_amount,
    int usdt_slp_amount,
    int usdt_tlp_amount,
    int root_amount,
    slice admin_address,
    int msg_value
) impure inline {
    cell state_init = calculate_user_sc_state_init(
        user_sc_code,
        admin_address,
        my_address(),
        root_master_address,
        jetton_wallet_code
    );
    slice to_address = calculate_sc_address(state_init);
    cell msg_body = begin_cell()
        .store_uint(op::deposit, 32)
        .store_uint(query_id, 64)
        .store_coins(total_deposit_amount)
        .store_coins(usdt_slp_amount)
        .store_coins(usdt_tlp_amount)
        .store_coins(root_amount)
        .end_cell();
    cell mint_user_sc_msg = begin_cell()
        .store_uint(0x10, 6)
        .store_slice(to_address)
        .store_coins(msg_value)
        .store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1)
        .store_ref(state_init)
        .store_ref(msg_body)
        .end_cell();
    send_raw_message(mint_user_sc_msg, SEND_MODE_REGULAR);
}

() send_evaa_withdraw(int query_id, cell price_data, int asset_id, int withdraw_amount, slice user_address) impure inline {
    cell msg_body = begin_cell()
        .store_uint(op::evaa_withdraw, 32)
        .store_uint(query_id, 64)
        .store_uint(asset_id, 256)
        .store_uint(withdraw_amount, 64)
        .store_slice(user_address)
        .store_int(-1, 2)
        .store_uint(0, 64)
        .store_ref(begin_cell().end_cell())
        .store_ref(price_data)
        .end_cell();
    cell msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(evaa_master_address)
        .store_coins(350000000) ;; 0.35 tons
        .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_ref(msg_body)
        .end_cell();
    send_raw_message(msg, SEND_MODE_REGULAR);
}

() send_excesses(int query_id, int msg_value, slice response_address) impure inline {
    cell msg = begin_cell()
        .store_uint(0x10, 6)
        .store_slice(response_address)
        .store_coins(msg_value)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(op::excesses, 32)
        .store_uint(query_id, 64)
        .end_cell();
    send_raw_message(msg, SEND_MODE_IGNORE_ERRORS);
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) {
        ;; ignore bounced messages
        return ();
    }
    if (in_msg_body.slice_bits() < 32) {
        ;; ignore simple transfers
        return ();
    }
    slice sender_address = cs~load_msg_addr();

    int op = in_msg_body~load_uint(32);
    if (op == op::text_comment) {
        ;; receive msgs with text comments
        return ();
    }
    int query_id = in_msg_body~load_uint(64);

    if (op == op::excesses) {
        ;; receive excesses
        return ();
    }

    load_data();
    if (op == op::transfer_notification) {
        slice usdt_jetton_wallet_address = get_jetton_wallet_governed_address(my_address(),usdt_jetton_master_address, jetton_wallet_governed_code);
        throw_unless(err::unknown_jetton, equal_slices(sender_address, usdt_jetton_wallet_address));

        (int jetton_amount, slice owner_address) = (in_msg_body~load_coins(), in_msg_body~load_msg_addr());

        if (is_address_none(owner_address)) {
            ;; ignore emptry addresses
            return ();
        }

        if (equal_slices(owner_address, evaa_master_address) | equal_slices(owner_address, storm_vault_address)) {
            return ();
        } else {
            jetton_amount -= 1000000; ;; 1 usdt fee

            int tradoor_deposit_amount = jetton_amount * 60 / 100;
            int storm_deposit_amount = jetton_amount * 40 / 100;
            ;; int evaa_deposit_amount = jetton_amount * 20 / 100;

            ;; but tlp
            cell tradoor_fwd_payload = begin_cell()
                .store_uint(op::tradoor_create_increase_lp_pos_order, 8)
                .store_coins(tradoor_deposit_amount)
                .store_coins(50000000) ;; 0.05 ton
                .end_cell();
            send_jettons(
                tradoor_deposit_amount,
                tradoor_master_address,
                query_id,
                usdt_jetton_wallet_address,
                tradoor_fwd_payload,
                100000000, ;; 0.1 ton
                150000000, ;; ;; 0.15 ton
                owner_address
            );

            ;; strom provide
            send_jettons(
                storm_deposit_amount,
                storm_vault_address,
                query_id,
                usdt_jetton_wallet_address,
                begin_cell().store_uint(op::storm_provide, 32).end_cell(),
                305000000, ;; 0.305 ton
                350000000, ;; ;; 0.35 ton
                owner_address
            );

            ;; evaa supply
            ;; cell evaa_fwd_paylod = begin_cell()
            ;;     .store_uint(op::evaa_supply, 32)
            ;;     .store_int(-1, 2)
            ;;     .store_slice(my_address())
            ;;     .store_uint(0, 64)
            ;;     .store_ref(begin_cell().end_cell())
            ;;     .end_cell();
            ;; send_jettons(
            ;;     evaa_deposit_amount,
            ;;     evaa_master_address,
            ;;     query_id,
            ;;     usdt_jetton_wallet_address,
            ;;     evaa_fwd_paylod,
            ;;     300000000, ;; 0.3 ton
            ;;     400000000, ;; ;; 0.4 ton
            ;;     owner_address
            ;; );

            ;; divide by 100 cause 1 ROOT ~ 100 USDT, mult by 1000 cause usdt have 6 decimals
            int mint_amount = (jetton_amount / root_price) * 1000;
            mint_jettons(query_id, mint_amount, owner_address, 8000000, 30000000);

            ;; fee
            send_jettons(
                1000000, ;; 1 usdt
                admin_address,
                query_id,
                usdt_jetton_wallet_address,
                begin_cell().end_cell(),
                1,
                50000000, ;; 0.05 ton
                owner_address
            );
        }
        return ();
    }
    if (op == op::mint_user_internal) {
        throw_unless(err::unknown_address, equal_slices(sender_address, admin_address));
        int usdt_tlp_amount = in_msg_body~load_coins();
        int usdt_slp_amount = in_msg_body~load_coins();
        int total_deposit_amount = in_msg_body~load_coins();
        slice admin_address = in_msg_body~load_msg_addr();
        in_msg_body.end_parse();
        int root_amount = (total_deposit_amount / root_price) * 1000;
        mint_user_sc(query_id, total_deposit_amount, usdt_slp_amount, usdt_tlp_amount, root_amount, admin_address, 30000000);
        send_excesses(query_id, 300000000, admin_address);
        return ();
    }
    if (op == op::withdraw) {
        slice admin_address = in_msg_body~load_msg_addr();
        int evaa_withdraw_amount = in_msg_body~load_coins();
        int usdt_slp_amount = in_msg_body~load_coins();
        int usdt_tlp_amount = in_msg_body~load_coins();
        cell price_data = in_msg_body~load_ref();
        in_msg_body.end_parse();

        cell state_init = calculate_user_sc_state_init(
            user_sc_code, admin_address, my_address(), root_master_address, jetton_wallet_code);
        slice user_sc_address = calculate_sc_address(state_init);
        throw_unless(err::not_child, equal_slices(sender_address, user_sc_address));

        ;; sell tlp
        send_jettons(
            usdt_tlp_amount,
            tradoor_master_address,
            query_id,
            usdt_tlp_jetton_wallet,
            begin_cell()
                .store_coins(usdt_tlp_amount)
                .store_coins(50000000) ;; 0.05 ton
                .end_cell(),
            100000000, ;; 0.1 ton
            150000000, ;; 0.15 ton
            admin_address
        );

        ;; evaa withdraw
        ;; send_evaa_withdraw(query_id, price_data, "USDT"H, evaa_withdraw_amount, my_address());

        ;; storm withdraw
        burn_jettons(usdt_slp_amount, usdt_slp_jetton_wallet, query_id, 300000000, admin_address);
        return();
    }
    if (op == op::upgrade_contract) {
        throw_unless(err::not_admin, equal_slices(sender_address, admin_address));
        (cell new_data, cell new_code) = (in_msg_body~load_ref(), in_msg_body~load_ref());
        in_msg_body.end_parse();
        set_data(new_data);
        set_code(new_code);
        return ();
    }
    if (op == op::update_root_price) {
        throw_unless(err::not_admin, equal_slices(sender_address, admin_address));
        int new_root_price = in_msg_body~load_uint(64);
        in_msg_body.end_parse();
        root_price = new_root_price;
        save_data();
        return ();
    }
    throw(err::unknown_op_code);
}

(slice, slice, cell, slice, cell, cell, int, slice, slice, slice, slice, slice) get_main_data() method_id {
    load_data();
    return (
        usdt_jetton_master_address,
        root_master_address,
        user_sc_code,
        admin_address,
        jetton_wallet_governed_code,
        jetton_wallet_code,
        root_price,
        evaa_master_address,
        tradoor_master_address,
        storm_vault_address,
        usdt_slp_jetton_wallet,
        usdt_tlp_jetton_wallet
    );
}

slice get_user_sc_address(slice user_address) method_id {
    load_data();
    cell state_init = calculate_user_sc_state_init(
        user_sc_code, user_address, my_address(), root_master_address, jetton_wallet_code);
    return calculate_sc_address(state_init);
}